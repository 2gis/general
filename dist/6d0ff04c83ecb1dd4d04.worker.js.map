{"version":3,"sources":["webpack:///6d0ff04c83ecb1dd4d04.worker.js","webpack:///webpack/bootstrap 6d0ff04c83ecb1dd4d04","webpack:///./src/markerArray.ts","webpack:///./src/worker.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","stride","offsets","members","length","reduce","member","index","collide","arr","width","bbox","x1","minX","y1","minY","x2","maxX","y2","maxY","j","start","end","sum","putToArray","isNaN","a","bboxIsEmpty","createBBox","dst","height","pixelRatio","size","anchor","pixelDensity","positionX","positionY","offset","spriteScale","__WEBPACK_IMPORTED_MODULE_0__markerArray__","collideBBox","marginBBox","degradationBBox","onmessage","event","data","bounds","priorityGroups","sprites","markers","markerCount","planeLength","plane","Uint8Array","currentDegradationPlane","degradationPlane","prevGroupIndex","pixelPositionX","pixelPositionY","_a","iconIndex","margin","degradation","sprite","group","safeZone","set","markerOffset","groupIndex","postMessage"],"mappings":"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","file":"6d0ff04c83ecb1dd4d04.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return stride; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return offsets; });\nvar members = [\n    'pixelPositionX',\n    'pixelPositionY',\n    'groupIndex',\n    'iconIndex',\n    'prevGroupIndex',\n];\nvar stride = members.length;\nvar offsets = members.reduce(function (offsets, member, index) {\n    offsets[member] = index;\n    return offsets;\n}, {});\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__markerArray__ = __webpack_require__(0);\n\nvar collideBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nvar marginBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nvar degradationBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nonmessage = function (event) {\n    var data = event.data;\n    var bounds = data.bounds, pixelRatio = data.pixelRatio, priorityGroups = data.priorityGroups, sprites = data.sprites, markers = data.markers, markerCount = data.markerCount;\n    var width = (bounds.maxX - bounds.minX >> 3) + 1 << 3; // Ширина должна быть кратна 8\n    var height = bounds.maxY - bounds.minY;\n    var planeLength = width * height + 8 >> 3;\n    /**\n     * Алгоритм действует по принципу закрашивания плоскости маркерами.\n     * Плоскость – массив, каждый элемент которого представляет собой пиксель на экране.\n     * Для ускорения процесса используется битовой массив, 1 бит – 1 пиксель.\n     * Всего у нас есть три плоскости:\n     */\n    // Это первая, с помощью нее мы просто проверяем попадание маркеров с safeZone и вставляем их с margin\n    var plane = new Uint8Array(planeLength);\n    /**\n     * Следующие две используются для проверки на деградацию маркеров.\n     * Область деградации маркера текущей группы действует только на маркера из следующей группы\n     * и не влияет на другие маркера текущей группы.\n     * Поэтому их две:\n     */\n    // Одна – для проверки текущей группы с предыдущими\n    var currentDegradationPlane = new Uint8Array(planeLength);\n    // Вторая – для передачи в следующие группы\n    var degradationPlane = new Uint8Array(planeLength);\n    /**\n     * Одни и те же маркера могут участвовать в генерализации несколько раз,\n     * такие маркера имеют поле prevGroupIndex.\n     *\n     * Чтобы не делать лишнюю работу, и чтобы результат генерализации был устойчив,\n     * мы используем результаты предыдущей генерализации.\n     */\n    // Поэтому вначале закрашиваем плоскость повторно генерализуемыми маркерами\n    for (var i = 0; i < markerCount; i++) {\n        var prevGroupIndex = markers[i * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */] + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].prevGroupIndex];\n        var pixelPositionX = markers[i * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */] + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionX];\n        var pixelPositionY = markers[i * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */] + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionY];\n        // prevGroupIndex не равен NaN, если маркер уже проходил генерализацию\n        if (!isNaN(prevGroupIndex)) {\n            var _a = priorityGroups[prevGroupIndex], iconIndex = _a.iconIndex, margin = _a.margin, degradation = _a.degradation;\n            var sprite = sprites[iconIndex];\n            if (!sprite) {\n                // smth shit\n                continue;\n            }\n            var size = sprite.size, anchor = sprite.anchor, pixelDensity = sprite.pixelDensity;\n            // Вставляем их на основную плоскость и плоскость деградции без всяких проверок\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, margin);\n            if (!bboxIsEmpty(marginBBox)) {\n                putToArray(plane, width, marginBBox);\n            }\n            createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, degradation);\n            if (!bboxIsEmpty(degradationBBox)) {\n                putToArray(degradationPlane, width, degradationBBox);\n            }\n        }\n    }\n    // Здесь начинает работу основной алгоритм генерализации.\n    // У нас два вложенных цикла: по группам -> по маркерам.\n    for (var i = 0; i < priorityGroups.length; i++) {\n        var group = priorityGroups[i];\n        var safeZone = group.safeZone, iconIndex = group.iconIndex, margin = group.margin, degradation = group.degradation;\n        var sprite = sprites[iconIndex];\n        if (!sprite) {\n            // smth shit\n            continue;\n        }\n        var size = sprite.size, anchor = sprite.anchor, pixelDensity = sprite.pixelDensity;\n        // Копируем область деградации от предудщих групп,\n        // чтобы маркера текущей группы не влияли друг на друга.\n        currentDegradationPlane.set(degradationPlane);\n        for (var j = 0; j < markerCount; j++) {\n            var markerOffset = j * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */];\n            var groupIndex = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].groupIndex];\n            var prevGroupIndex = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].prevGroupIndex];\n            var pixelPositionX = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionX];\n            var pixelPositionY = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionY];\n            // Пропускаем маркера, чей изначальный groupIndex больше индекса текущей перебираемой группы.\n            // Такие маркера будут проверены в следующах группах.\n            // Также пропускаем повторно генерализуемые маркера.\n            if (groupIndex > i || !isNaN(prevGroupIndex)) {\n                continue;\n            }\n            // Маркер первый раз попал в область деградации – пропускаем\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, margin);\n            if (bboxIsEmpty(marginBBox) ||\n                (groupIndex === i && collide(currentDegradationPlane, width, marginBBox))) {\n                continue;\n            }\n            // Область маркера пересекает область уже вставшего маркера – пропускаем\n            createBBox(collideBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, safeZone);\n            if (bboxIsEmpty(collideBBox)) {\n                continue;\n            }\n            if (!collide(plane, width, collideBBox)) {\n                createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, degradation);\n                // Если все хорошо и маркер выжил, закрашиваем его в двух плоскостях\n                putToArray(plane, width, marginBBox);\n                putToArray(degradationPlane, width, degradationBBox);\n                markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].iconIndex] = iconIndex;\n                markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].prevGroupIndex] = i;\n            }\n        }\n    }\n    postMessage(markers);\n};\n/**\n * Проверяет, пересекает ли область что-либо в плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Проверяемая область\n * @returns {boolean}\n */\nfunction collide(arr, width, bbox) {\n    var x1 = bbox.minX;\n    var y1 = bbox.minY;\n    var x2 = bbox.maxX;\n    var y2 = bbox.maxY;\n    for (var j = y1; j < y2; j++) {\n        var start = j * width + x1 >> 3;\n        var end = j * width + x2 >> 3;\n        var sum = 0;\n        // Если начальный байт равен конечному, то нужно проверить только его\n        if (start === end) {\n            sum = arr[start] & (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        }\n        else {\n            // Проверяем начальный байт\n            sum = arr[start] & (255 >> (x1 & 7));\n            // Перебираем все промежуточные между начальным и конечным\n            for (var i = start + 1; i < end; i++) {\n                sum = arr[i] | sum;\n            }\n            // Проверяем конечный байт\n            sum = arr[end] & (255 << (8 - (x2 & 7))) | sum;\n        }\n        if (sum !== 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Закрашиваем переданную область на плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Закрашиваемая область\n */\nfunction putToArray(arr, width, bbox) {\n    var x1 = bbox.minX;\n    var y1 = bbox.minY;\n    var x2 = bbox.maxX;\n    var y2 = bbox.maxY;\n    for (var j = y1; j < y2; j++) {\n        var start = j * width + x1 >> 3;\n        var end = j * width + x2 >> 3;\n        // Если начальный байт равен конечному, то нужно закрасить биты только в нем\n        if (start === end) {\n            arr[start] = arr[start] | (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        }\n        else {\n            // Закрашиваем биты в начальном байте\n            arr[start] = arr[start] | (255 >> (x1 & 7));\n            // Закрашиваем все промежуточные байты между начальным и конечным\n            for (var i = start + 1; i < end; i++) {\n                arr[i] = 255;\n            }\n            // Закрашиваем биты в коненом байте\n            arr[end] = arr[end] | (255 << (8 - (x2 & 7)));\n        }\n    }\n}\nfunction isNaN(a) {\n    return a !== a;\n}\nfunction bboxIsEmpty(a) {\n    return a.minX === a.maxX || a.minY === a.maxY;\n}\nfunction createBBox(dst, width, height, pixelRatio, size, anchor, pixelDensity, positionX, positionY, offset) {\n    var spriteScale = pixelRatio / pixelDensity;\n    var x1 = positionX * pixelRatio - size[0] * spriteScale * anchor[0] - offset | 0;\n    var y1 = positionY * pixelRatio - size[1] * spriteScale * anchor[1] - offset | 0;\n    var x2 = positionX * pixelRatio + size[0] * spriteScale * (1 - anchor[0]) + offset | 0;\n    var y2 = positionY * pixelRatio + size[1] * spriteScale * (1 - anchor[1]) + offset | 0;\n    // Обрезаем область по установленным границам плоскости\n    dst.minX = x1 > 0 ? (x1 < width ? x1 : width) : 0;\n    dst.minY = y1 > 0 ? (y1 < height ? y1 : height) : 0;\n    dst.maxX = x2 > 0 ? (x2 < width ? x2 : width) : 0;\n    dst.maxY = y2 > 0 ? (y2 < height ? y2 : height) : 0;\n}\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 6d0ff04c83ecb1dd4d04.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6d0ff04c83ecb1dd4d04","const members = [\n    'pixelPositionX',\n    'pixelPositionY',\n    'groupIndex',\n    'iconIndex',\n    'prevGroupIndex',\n];\n\nexport const stride = members.length;\nexport const offsets: {[key: string]: number} = members.reduce((offsets, member, index) => {\n    offsets[member] = index;\n    return offsets;\n}, {});\n\n\n\n// WEBPACK FOOTER //\n// ./src/markerArray.ts","import { stride, offsets } from './markerArray';\nvar collideBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nvar marginBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nvar degradationBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nonmessage = function (event) {\n    var data = event.data;\n    var bounds = data.bounds, pixelRatio = data.pixelRatio, priorityGroups = data.priorityGroups, sprites = data.sprites, markers = data.markers, markerCount = data.markerCount;\n    var width = (bounds.maxX - bounds.minX >> 3) + 1 << 3; // Ширина должна быть кратна 8\n    var height = bounds.maxY - bounds.minY;\n    var planeLength = width * height + 8 >> 3;\n    /**\n     * Алгоритм действует по принципу закрашивания плоскости маркерами.\n     * Плоскость – массив, каждый элемент которого представляет собой пиксель на экране.\n     * Для ускорения процесса используется битовой массив, 1 бит – 1 пиксель.\n     * Всего у нас есть три плоскости:\n     */\n    // Это первая, с помощью нее мы просто проверяем попадание маркеров с safeZone и вставляем их с margin\n    var plane = new Uint8Array(planeLength);\n    /**\n     * Следующие две используются для проверки на деградацию маркеров.\n     * Область деградации маркера текущей группы действует только на маркера из следующей группы\n     * и не влияет на другие маркера текущей группы.\n     * Поэтому их две:\n     */\n    // Одна – для проверки текущей группы с предыдущими\n    var currentDegradationPlane = new Uint8Array(planeLength);\n    // Вторая – для передачи в следующие группы\n    var degradationPlane = new Uint8Array(planeLength);\n    /**\n     * Одни и те же маркера могут участвовать в генерализации несколько раз,\n     * такие маркера имеют поле prevGroupIndex.\n     *\n     * Чтобы не делать лишнюю работу, и чтобы результат генерализации был устойчив,\n     * мы используем результаты предыдущей генерализации.\n     */\n    // Поэтому вначале закрашиваем плоскость повторно генерализуемыми маркерами\n    for (var i = 0; i < markerCount; i++) {\n        var prevGroupIndex = markers[i * stride + offsets.prevGroupIndex];\n        var pixelPositionX = markers[i * stride + offsets.pixelPositionX];\n        var pixelPositionY = markers[i * stride + offsets.pixelPositionY];\n        // prevGroupIndex не равен NaN, если маркер уже проходил генерализацию\n        if (!isNaN(prevGroupIndex)) {\n            var _a = priorityGroups[prevGroupIndex], iconIndex = _a.iconIndex, margin = _a.margin, degradation = _a.degradation;\n            var sprite = sprites[iconIndex];\n            if (!sprite) {\n                // smth shit\n                continue;\n            }\n            var size = sprite.size, anchor = sprite.anchor, pixelDensity = sprite.pixelDensity;\n            // Вставляем их на основную плоскость и плоскость деградции без всяких проверок\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, margin);\n            if (!bboxIsEmpty(marginBBox)) {\n                putToArray(plane, width, marginBBox);\n            }\n            createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, degradation);\n            if (!bboxIsEmpty(degradationBBox)) {\n                putToArray(degradationPlane, width, degradationBBox);\n            }\n        }\n    }\n    // Здесь начинает работу основной алгоритм генерализации.\n    // У нас два вложенных цикла: по группам -> по маркерам.\n    for (var i = 0; i < priorityGroups.length; i++) {\n        var group = priorityGroups[i];\n        var safeZone = group.safeZone, iconIndex = group.iconIndex, margin = group.margin, degradation = group.degradation;\n        var sprite = sprites[iconIndex];\n        if (!sprite) {\n            // smth shit\n            continue;\n        }\n        var size = sprite.size, anchor = sprite.anchor, pixelDensity = sprite.pixelDensity;\n        // Копируем область деградации от предудщих групп,\n        // чтобы маркера текущей группы не влияли друг на друга.\n        currentDegradationPlane.set(degradationPlane);\n        for (var j = 0; j < markerCount; j++) {\n            var markerOffset = j * stride;\n            var groupIndex = markers[markerOffset + offsets.groupIndex];\n            var prevGroupIndex = markers[markerOffset + offsets.prevGroupIndex];\n            var pixelPositionX = markers[markerOffset + offsets.pixelPositionX];\n            var pixelPositionY = markers[markerOffset + offsets.pixelPositionY];\n            // Пропускаем маркера, чей изначальный groupIndex больше индекса текущей перебираемой группы.\n            // Такие маркера будут проверены в следующах группах.\n            // Также пропускаем повторно генерализуемые маркера.\n            if (groupIndex > i || !isNaN(prevGroupIndex)) {\n                continue;\n            }\n            // Маркер первый раз попал в область деградации – пропускаем\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, margin);\n            if (bboxIsEmpty(marginBBox) ||\n                (groupIndex === i && collide(currentDegradationPlane, width, marginBBox))) {\n                continue;\n            }\n            // Область маркера пересекает область уже вставшего маркера – пропускаем\n            createBBox(collideBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, safeZone);\n            if (bboxIsEmpty(collideBBox)) {\n                continue;\n            }\n            if (!collide(plane, width, collideBBox)) {\n                createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, degradation);\n                // Если все хорошо и маркер выжил, закрашиваем его в двух плоскостях\n                putToArray(plane, width, marginBBox);\n                putToArray(degradationPlane, width, degradationBBox);\n                markers[markerOffset + offsets.iconIndex] = iconIndex;\n                markers[markerOffset + offsets.prevGroupIndex] = i;\n            }\n        }\n    }\n    postMessage(markers);\n};\n/**\n * Проверяет, пересекает ли область что-либо в плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Проверяемая область\n * @returns {boolean}\n */\nfunction collide(arr, width, bbox) {\n    var x1 = bbox.minX;\n    var y1 = bbox.minY;\n    var x2 = bbox.maxX;\n    var y2 = bbox.maxY;\n    for (var j = y1; j < y2; j++) {\n        var start = j * width + x1 >> 3;\n        var end = j * width + x2 >> 3;\n        var sum = 0;\n        // Если начальный байт равен конечному, то нужно проверить только его\n        if (start === end) {\n            sum = arr[start] & (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        }\n        else {\n            // Проверяем начальный байт\n            sum = arr[start] & (255 >> (x1 & 7));\n            // Перебираем все промежуточные между начальным и конечным\n            for (var i = start + 1; i < end; i++) {\n                sum = arr[i] | sum;\n            }\n            // Проверяем конечный байт\n            sum = arr[end] & (255 << (8 - (x2 & 7))) | sum;\n        }\n        if (sum !== 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Закрашиваем переданную область на плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Закрашиваемая область\n */\nfunction putToArray(arr, width, bbox) {\n    var x1 = bbox.minX;\n    var y1 = bbox.minY;\n    var x2 = bbox.maxX;\n    var y2 = bbox.maxY;\n    for (var j = y1; j < y2; j++) {\n        var start = j * width + x1 >> 3;\n        var end = j * width + x2 >> 3;\n        // Если начальный байт равен конечному, то нужно закрасить биты только в нем\n        if (start === end) {\n            arr[start] = arr[start] | (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        }\n        else {\n            // Закрашиваем биты в начальном байте\n            arr[start] = arr[start] | (255 >> (x1 & 7));\n            // Закрашиваем все промежуточные байты между начальным и конечным\n            for (var i = start + 1; i < end; i++) {\n                arr[i] = 255;\n            }\n            // Закрашиваем биты в коненом байте\n            arr[end] = arr[end] | (255 << (8 - (x2 & 7)));\n        }\n    }\n}\nfunction isNaN(a) {\n    return a !== a;\n}\nfunction bboxIsEmpty(a) {\n    return a.minX === a.maxX || a.minY === a.maxY;\n}\nfunction createBBox(dst, width, height, pixelRatio, size, anchor, pixelDensity, positionX, positionY, offset) {\n    var spriteScale = pixelRatio / pixelDensity;\n    var x1 = positionX * pixelRatio - size[0] * spriteScale * anchor[0] - offset | 0;\n    var y1 = positionY * pixelRatio - size[1] * spriteScale * anchor[1] - offset | 0;\n    var x2 = positionX * pixelRatio + size[0] * spriteScale * (1 - anchor[0]) + offset | 0;\n    var y2 = positionY * pixelRatio + size[1] * spriteScale * (1 - anchor[1]) + offset | 0;\n    // Обрезаем область по установленным границам плоскости\n    dst.minX = x1 > 0 ? (x1 < width ? x1 : width) : 0;\n    dst.minY = y1 > 0 ? (y1 < height ? y1 : height) : 0;\n    dst.maxX = x2 > 0 ? (x2 < width ? x2 : width) : 0;\n    dst.maxY = y2 > 0 ? (y2 < height ? y2 : height) : 0;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/ts-loader!./src/worker.ts"],"sourceRoot":""}