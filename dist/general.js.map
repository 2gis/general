{"version":3,"sources":["webpack://General/webpack/universalModuleDefinition","webpack://General/webpack/bootstrap","webpack://General/./src/markerArray.ts","webpack://General/./src/labelArray.ts","webpack://General/./node_modules/webworkify-webpack/index.js","webpack://General/./src/worker/minZoom.ts","webpack://General/./src/worker/generalize.ts","webpack://General/./src/worker/index.ts","webpack://General/./src/General.ts","webpack://General/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","offsets","stride","pack","unpack","pixelPositionX","pixelPositionY","groupIndex","iconIndex","priority","keys","length","markerArray","markers","i_1","markerOffset","marker","pixelPosition","Boolean","i_2","markerIndex","offsetX","offsetY","width","height","display","minZoom","labelArray","devicePixelRatio","labelOffset","label","htmlLabel","undefined","offset","_i","markers_1","webpackBootstrapFunc","configurable","oe","err","console","error","f","ENTRY_MODULE","default","moduleNameReqExp","dependencyRegExp","quoteRegExp","str","replace","getModuleDependencies","sources","queueName","retval","fnString","toString","wrapperSignature","match","webpackRequireName","re","RegExp","exec","push","j","isNaN","hasValuesInQueues","queues","reduce","hasValues","options","main","requiredModules","all","modulesQueue","seenModules","moduleToCheck","pop","newModules","newModulesKeys","concat","getRequiredModules","src","filter","forEach","entryModule","JSON","stringify","map","id","join","blob","Blob","type","bare","workerUrl","URL","webkitURL","mozURL","msURL","createObjectURL","worker","Worker","objectURL","intersectionRangeX","min","Infinity","max","intersectionRangeY","intersectionRange","intersectionRangeLimit","getIntersectionZoom","bbox1","bbox2","currentZoom","dest","interval1","interval2","interval3","dx","anchorX","dy","anchorY","calcIntersectionRange","minX","maxX","minY","maxY","Math","log","min1","max1","min2","max2","d0","abs","collideBBox","marginBBox","degradationBBox","noMarginBBox","survivedLabelBoxes","generalize","data","bounds","priorityGroups","markerCount","labels","labelCount","planeWidth","planeHeight","planeLength","plane","Uint8Array","labelPlane","degradationPlanes","prevIconIndices","Int8Array","index","prevLabelState","prevLabelMinZoom","Float32Array","displayIndex","minZoomIndex","generalizeMarkers","generalizeLabels","processVisible","processPriority","sprites","prevDegradationPlane","degradationPlane","isVisible","isPriority","generalizeMarker","generalizeLabel","_a","safeZone","margin","degradation","_b","size","anchor","markerGroupIndex","createBBox","bboxIsEmpty","collide","putToArray","labelIndex","labelBox","survivedLabelBoxes_1","existingBox","arr","bbox","x1","y1","x2","y2","start","end","sum","a","dst","positionX","positionY","self","onmessage","event","postMessage","buffer","General_General","General","_this","this","webworkify_webpack_default","queue","currentJob","resolve","dequeue","message","Promise","clear","job","shift"],"mappings":"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","file":"general.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"General\"] = factory();\n\telse\n\t\troot[\"General\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","import { Marker } from './types';\n\n// Оффсеты должны быть пронумерованы по порядку\nlet i = 0;\nexport const offsets = {\n    pixelPositionX: i++,\n    pixelPositionY: i++,\n    groupIndex: i++,\n    iconIndex: i++,\n    priority: i++,\n};\n\nexport const stride = Object.keys(offsets).length;\n\n/**\n * Запаковывает переданный массив маркеров в типизированный массив для быстрой передачи в воркер\n */\nexport function pack(markerArray: Float32Array, markers: Marker[]) {\n    for (let i = 0, markerOffset = 0; i < markers.length; i++, markerOffset += stride) {\n        const marker = markers[i];\n\n        markerArray[markerOffset + offsets.pixelPositionX] = marker.pixelPosition[0];\n        markerArray[markerOffset + offsets.pixelPositionY] = marker.pixelPosition[1];\n        markerArray[markerOffset + offsets.groupIndex] = marker.groupIndex;\n        markerArray[markerOffset + offsets.iconIndex] = marker.iconIndex;\n        markerArray[markerOffset + offsets.priority] = Boolean(marker.priority) ? 1 : 0;\n    }\n}\n\n/**\n * Вынимает значения из запакованного типизированного массива в массив маркеров\n */\nexport function unpack(markers: Marker[], markerArray: Float32Array) {\n    for (let i = 0, markerOffset = 0; i < markers.length; i++, markerOffset += stride) {\n        markers[i].iconIndex = markerArray[markerOffset + offsets.iconIndex];\n    }\n}\n","import { Marker } from './types';\n\nlet i = 0;\nexport const offsets = {\n    markerIndex: i++,\n    offsetX: i++,\n    offsetY: i++,\n    width: i++,\n    height: i++,\n    display: i++,\n    minZoom: i++,\n};\n\nexport const stride = i;\n\n/**\n * Запаковывает переданный массив маркеров в типизированный массив для быстрой передачи в воркер\n */\nexport function pack(labelArray: Float32Array, markers: Marker[], devicePixelRatio: number) {\n    let labelOffset = 0;\n\n    for (let i = 0; i < markers.length; i++) {\n        const label = markers[i].htmlLabel;\n\n        if (label === undefined) {\n            continue;\n        }\n\n        labelArray[labelOffset + offsets.markerIndex] = i;\n        labelArray[labelOffset + offsets.offsetX] = label.offset[0] * devicePixelRatio;\n        labelArray[labelOffset + offsets.offsetY] = label.offset[1] * devicePixelRatio;\n        labelArray[labelOffset + offsets.width] = label.width * devicePixelRatio;\n        labelArray[labelOffset + offsets.height] = label.height * devicePixelRatio;\n        labelArray[labelOffset + offsets.display] = label.display ? 1 : 0;\n        labelArray[labelOffset + offsets.minZoom] = label.minZoom;\n\n        labelOffset += stride;\n    }\n}\n\n/**\n * Вынимает значения из запакованного типизированного массива в массив маркеров\n */\nexport function unpack(markers: Marker[], labelArray: Float32Array) {\n    let labelOffset = 0;\n\n    for (const marker of markers) {\n        const {htmlLabel: label} = marker;\n\n        if (label === undefined) {\n            continue;\n        }\n\n        label.display = labelArray[labelOffset + offsets.display] === 1;\n        label.minZoom = labelArray[labelOffset + offsets.minZoom];\n\n        labelOffset += stride;\n    }\n}\n","function webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __webpack_require__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __webpack_require__.m = modules;\n\n/******/  // expose the module cache\n/******/  __webpack_require__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __webpack_require__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __webpack_require__.d = function(exports, name, getter) {\n/******/    if(!__webpack_require__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __webpack_require__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __webpack_require__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __webpack_require__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __webpack_require__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __webpack_require__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __webpack_modules__\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n","import { LabelBBox } from '../types';\n\ninterface Interval {\n    min: number;\n    max: number;\n}\n\nconst intersectionRangeX: Interval = { min: -Infinity, max: Infinity };\nconst intersectionRangeY: Interval = { min: -Infinity, max: Infinity };\nconst intersectionRange: Interval = { min: -Infinity, max: Infinity };\n\nconst intersectionRangeLimit: Interval = { min: 0, max: Infinity };\n\n/**\n * Вычисляет зум, на котором лейблинг-боксы bbox1 и bbox2 начинают пересекаться.\n *\n * BBox определяется:\n * 1. Якорем — точкой в координатах экрана\n * 2. Оффсетами от якоря, обозначающими границы бокса в каждую из четырёх сторон от якоря.\n *    Оффсеты называются minX, maxX, minY и maxY.\n *\n * Фукнция работает следующим образом:\n * 1. Вычисляет текущее расстояние между якорями боксов по двум осям (dx и dy).\n * 2. Вычисляет диапазон расстояний dx и dy, внутри которых боксы будут пересекаться.\n *    Эти вычисления производятся отдельно для двух осей. Результаты вычислений делятся\n *    на текущие расстояния dx и dy. Таким образом, мы получаем результат в виде\n *    множителей текущего расстояния.\n * 3. Выполняется пересечение полученных интервалов для x и y.\n * 4. Берётся максимальное граница интервала, из него вычисляется финальное значение зума.\n */\nexport function getIntersectionZoom(\n    bbox1: LabelBBox,\n    bbox2: LabelBBox,\n    currentZoom: number,\n): number {\n    // Вычисляем текущее расстояние между якорями боксов\n    const dx = bbox2.anchorX - bbox1.anchorX;\n    const dy = bbox2.anchorY - bbox1.anchorY;\n\n    // Вычисляем диапазон множителей dx, внутри которого боксы пересекаются вдоль оси X\n    calcIntersectionRange(\n        intersectionRangeX,\n        bbox1.minX,\n        bbox1.maxX,\n        bbox2.minX,\n        bbox2.maxX,\n        dx,\n    );\n\n    // Вычисляем диапазон множителей dy, внутри которого боксы пересекаются вдоль оси Y\n    calcIntersectionRange(\n        intersectionRangeY,\n        bbox1.minY,\n        bbox1.maxY,\n        bbox2.minY,\n        bbox2.maxY,\n        dy,\n    );\n\n    // Находим пересечение этих диапазонов\n    intersect(\n        intersectionRange,\n        intersectionRangeX,\n        intersectionRangeY,\n        intersectionRangeLimit,\n    );\n\n    // Получили пустой интервал — боксы не пересекутся никогда\n    if (intersectionRange.min >= intersectionRange.max) {\n        return -Infinity;\n    }\n\n    // Берём максимальное значение диапазона и вычисляем из него зум\n    return currentZoom + Math.log(intersectionRange.max) / Math.log(2);\n}\n\n/**\n * Вычисляет диапазон расстояний между якорями, в котором два бокса пересекаются вдоль одной оси.\n */\nfunction calcIntersectionRange(\n    dest: Interval,\n    min1: number,\n    max1: number,\n    min2: number,\n    max2: number,\n    d0: number,\n): void {\n    const min = d0 > 0 ? min1 - max2 : min2 - max1;\n    const max = d0 > 0 ? max1 - min2 : max2 - min1;\n\n    dest.min = min / Math.abs(d0);\n    dest.max = max / Math.abs(d0);\n}\n\n/**\n * Выполняет операцию пересечения трёх интервалов. Результат записывается в интервал dest.\n */\nfunction intersect(\n    dest: Interval,\n    interval1: Interval,\n    interval2: Interval,\n    interval3: Interval,\n): void {\n    dest.min = Math.max(interval1.min, interval2.min, interval3.min);\n    dest.max = Math.min(interval1.max, interval2.max, interval3.max);\n}\n","import { BBox, Vec2, WorkerMessage, PriorityGroup, Sprite, LabelBBox } from '../types';\nimport { getIntersectionZoom } from './minZoom';\nimport * as markerArray from '../markerArray';\nimport * as labelArray from '../labelArray';\n\nconst collideBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nconst marginBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nconst degradationBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nconst noMarginBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\nlet survivedLabelBoxes: LabelBBox[] = [];\n\nexport function generalize(data: WorkerMessage) {\n    const { bounds, priorityGroups, markers, markerCount, labels, labelCount } = data;\n\n    const planeWidth = (bounds.maxX - bounds.minX >> 3) + 1 << 3; // Ширина должна быть кратна 8\n    const planeHeight = bounds.maxY - bounds.minY;\n\n    const planeLength = planeWidth * planeHeight + 8 >> 3;\n\n    /**\n     * Алгоритм действует по принципу закрашивания плоскости маркерами.\n     * Плоскость – массив, каждый элемент которого представляет собой пиксель на экране.\n     * Для ускорения процесса используется битовой массив, 1 бит – 1 пиксель.\n     * У нас есть несколько плоскостей.\n     */\n\n    // С помощью этой плоскости проверяется попадание маркеров с safeZone и вставляется они с margin\n    const plane = new Uint8Array(planeLength);\n\n    // Эта плоскость используется для подписей\n    const labelPlane = new Uint8Array(planeLength);\n\n    /**\n     * Следующие плоскости используются для проверки на деградацию маркеров.\n     *\n     * Область деградации маркера текущей группы действует только на маркера из следующей группы\n     * и не влияет на другие маркера текущей группы.\n     *\n     * Поэтому на каждую группу, кроме последней, нужно создавать свою плоскость,\n     * которая будет использоваться с последующими группами.\n     */\n\n    const degradationPlanes: Uint8Array[] = [];\n    for (let i = 0; i < priorityGroups.length; i++) {\n        degradationPlanes[i] = new Uint8Array(planeLength);\n    }\n\n    const prevIconIndices = new Int8Array(markerCount);\n    for (let i = 0; i < markerCount; i++) {\n        const index = i * markerArray.stride + markerArray.offsets.iconIndex;\n\n        // Сохраняем предыдущие индексы иконок для работы гистерезиса\n        prevIconIndices[i] = markers[index];\n\n        // Сбрасываем значение iconIndex у маркера\n        markers[index] = -1;\n    }\n\n    const prevLabelState = new Uint8Array(labelCount);\n    const prevLabelMinZoom = new Float32Array(labelCount);\n    for (let i = 0; i < labelCount; i++) {\n        const displayIndex = i * labelArray.stride + labelArray.offsets.display;\n        const minZoomIndex = i * labelArray.stride + labelArray.offsets.minZoom;\n\n        // Сохраняем предыдущее состояние лейблов\n        prevLabelState[i] = labels[displayIndex];\n        prevLabelMinZoom[i] = labels[minZoomIndex];\n\n        // Сбрасываем состояние лейблов\n        labels[displayIndex] = 0;\n        labels[minZoomIndex] = -Infinity;\n    }\n\n    survivedLabelBoxes = [];\n\n    // Здесь начинает работу основной алгоритм генерализации\n    // Генерализуем в таком порядке:\n    // 1. Приоритетные маркеры, видимые на экране\n    // 2. Приоритетные маркеры, не видимые на экране\n    // 3. Приоритетные подписи, видимые на экране\n    // 4. Приоритетные подписи, не видимые на экране\n    // 5. Неприоритетные маркеры, видимые на экране\n    // 6. Неприоритетные маркеры, не видимые на экране\n    // 7. Неприоритетные подписи, видимые на экране\n    // 8. Неприоритетные подписи, не видимые на экране\n    generalizeMarkers(\n        data, plane, degradationPlanes, planeWidth, planeHeight,\n        prevIconIndices, true, true,\n    );\n    generalizeMarkers(\n        data, plane, degradationPlanes, planeWidth, planeHeight,\n        prevIconIndices, false, true,\n    );\n\n    generalizeLabels(\n        data, labelPlane, planeWidth, planeHeight, prevLabelState,\n        prevLabelMinZoom, true, true,\n    );\n    generalizeLabels(\n        data, labelPlane, planeWidth, planeHeight, prevLabelState,\n        prevLabelMinZoom, false, true,\n    );\n\n    generalizeMarkers(\n        data, plane, degradationPlanes, planeWidth, planeHeight,\n        prevIconIndices, true, false,\n    );\n    generalizeMarkers(\n        data, plane, degradationPlanes, planeWidth, planeHeight,\n        prevIconIndices, false, false,\n    );\n\n    generalizeLabels(\n        data, labelPlane, planeWidth, planeHeight, prevLabelState,\n        prevLabelMinZoom, true, false,\n    );\n    generalizeLabels(\n        data, labelPlane, planeWidth, planeHeight, prevLabelState,\n        prevLabelMinZoom, false, false,\n    );\n}\n\nfunction generalizeMarkers(\n    data: WorkerMessage,\n    plane: Uint8Array,\n    degradationPlanes: Uint8Array[],\n    planeWidth: number,\n    planeHeight: number,\n    prevIconIndices: Int8Array,\n    processVisible: boolean,\n    processPriority: boolean,\n): void {\n    const { bounds, priorityGroups, sprites, markers, markerCount } = data;\n\n    for (let i = 0; i < priorityGroups.length; i++) {\n        const sprite = sprites[priorityGroups[i].iconIndex];\n        if (!sprite) {\n            // Защищаемся от ситуации, когда в конфиге передан некорректный индекс спрайта\n            continue;\n        }\n\n        const prevDegradationPlane = i !== 0 ? degradationPlanes[i - 1] : undefined;\n        const degradationPlane = i !== priorityGroups.length - 1 ? degradationPlanes[i] : undefined;\n\n        for (let j = 0; j < markerCount; j++) {\n            const isVisible = prevIconIndices[j] !== -1;\n            const isPriority = markers[markerArray.stride * j + markerArray.offsets.priority] === 1;\n\n            const visibilityOk = processVisible && isVisible || !processVisible && !isVisible;\n            const priorityOk = processPriority && isPriority || !processPriority && !isPriority;\n\n            if (visibilityOk && priorityOk) {\n                generalizeMarker(\n                    markers,\n                    priorityGroups,\n                    sprites,\n                    bounds,\n                    prevDegradationPlane,\n                    degradationPlane,\n                    plane,\n                    planeWidth,\n                    planeHeight,\n                    i, j,\n                );\n            }\n        }\n    }\n}\n\nfunction generalizeLabels(\n    data: WorkerMessage,\n    labelPlane: Uint8Array,\n    planeWidth: number,\n    planeHeight: number,\n    prevLabelState: Uint8Array,\n    prevLabelMinZoom: Float32Array,\n    processVisible: boolean,\n    processPriority: boolean,\n): void {\n    const { bounds, markers, labels, labelCount, currentZoom } = data;\n\n    for (let i = 0; i < labelCount; i++) {\n        const markerIndex = labels[i * labelArray.stride + labelArray.offsets.markerIndex];\n\n        const isVisible = prevLabelState[i] === 1 && currentZoom >= prevLabelMinZoom[i];\n        const isPriority = markers[markerIndex * markerArray.stride + markerArray.offsets.priority] === 1;\n\n        const visibilityOk = processVisible && isVisible || !processVisible && !isVisible;\n        const priorityOk = processPriority && isPriority || !processPriority && !isPriority;\n\n        if (visibilityOk && priorityOk) {\n            generalizeLabel(markers, labels, bounds, labelPlane, planeWidth, planeHeight, currentZoom, i);\n        }\n    }\n}\n\nfunction generalizeMarker(\n    markers: Float32Array,\n    priorityGroups: PriorityGroup[],\n    sprites: Sprite[],\n    bounds: BBox,\n    prevDegradationPlane: Uint8Array | undefined,\n    degradationPlane: Uint8Array | undefined,\n    plane: Uint8Array,\n    planeWidth: number,\n    planeHeight: number,\n    groupIndex: number,\n    markerIndex: number,\n): void {\n    const { safeZone, iconIndex, margin, degradation } = priorityGroups[groupIndex];\n    const { size, anchor } = sprites[iconIndex];\n    const { stride, offsets } = markerArray;\n\n    const markerOffset = markerIndex * stride;\n    const markerGroupIndex = markers[markerOffset + offsets.groupIndex];\n    const pixelPositionX = markers[markerOffset + offsets.pixelPositionX] - bounds.minX;\n    const pixelPositionY = markers[markerOffset + offsets.pixelPositionY] - bounds.minY;\n\n    // Пропускаем маркера, чей изначальный groupIndex больше индекса текущей перебираемой группы.\n    // Такие маркера будут проверены в следующах группах.\n    if (markerGroupIndex > groupIndex) {\n        return;\n    }\n\n    // Маркер первый раз попал в область деградации – пропускаем\n    createBBox(marginBBox, planeWidth, planeHeight, size, anchor, pixelPositionX, pixelPositionY, margin);\n    if (bboxIsEmpty(marginBBox) || (markerGroupIndex === groupIndex &&\n            prevDegradationPlane && collide(prevDegradationPlane, planeWidth, marginBBox))\n    ) {\n        return;\n    }\n\n    // Область маркера пересекает область уже вставшего маркера – пропускаем\n    createBBox(collideBBox, planeWidth, planeHeight, size, anchor, pixelPositionX, pixelPositionY, safeZone);\n    if (bboxIsEmpty(collideBBox)) {\n        return;\n    }\n\n    if (!collide(plane, planeWidth, collideBBox)) {\n        createBBox(degradationBBox, planeWidth, planeHeight, size, anchor,\n            pixelPositionX, pixelPositionY, degradation);\n\n        // Если все хорошо и маркер выжил, закрашиваем его в плоскости\n        putToArray(plane, planeWidth, marginBBox);\n\n        if (degradationPlane) {\n            putToArray(degradationPlane, planeWidth, degradationBBox);\n        }\n\n        markers[markerOffset + offsets.iconIndex] = iconIndex;\n    }\n}\n\nfunction generalizeLabel(\n    markers: Float32Array,\n    labels: Float32Array,\n    bounds: BBox,\n    labelPlane: Uint8Array,\n    planeWidth: number,\n    planeHeight: number,\n    currentZoom: number,\n    labelIndex: number,\n): void {\n    const { stride, offsets } = labelArray;\n    const labelOffset = labelIndex * stride;\n\n    const markerIndex = labels[labelOffset + offsets.markerIndex];\n    const markerOffset = markerIndex * markerArray.stride;\n    const markerIsDisplayed = markers[markerOffset + markerArray.offsets.iconIndex] !== -1;\n\n    if (!markerIsDisplayed) {\n        return;\n    }\n\n    const pixelPositionX = markers[markerOffset + markerArray.offsets.pixelPositionX] - bounds.minX;\n    const pixelPositionY = markers[markerOffset + markerArray.offsets.pixelPositionY] - bounds.minY;\n\n    const size = [\n        labels[labelOffset + offsets.width],\n        labels[labelOffset + offsets.height],\n    ];\n\n    const anchor = [\n        -labels[labelOffset + offsets.offsetX] / size[0],\n        -labels[labelOffset + offsets.offsetY] / size[1],\n    ];\n\n    createBBox(noMarginBBox, planeWidth, planeHeight, size, anchor, pixelPositionX, pixelPositionY, 0);\n    if (bboxIsEmpty(noMarginBBox)) {\n        return;\n    }\n\n    if (!collide(labelPlane, planeWidth, noMarginBBox)) {\n        putToArray(labelPlane, planeWidth, noMarginBBox);\n        labels[labelOffset + offsets.display] = 1;\n\n        const labelBox: LabelBBox = {\n            anchorX: pixelPositionX,\n            anchorY: pixelPositionY,\n            minX: -size[0] * anchor[0],\n            minY: -size[1] * anchor[1],\n            maxX: size[0] * (1 - anchor[0]),\n            maxY: size[1] * (1 - anchor[1]),\n            minZoom: -Infinity,\n        };\n\n        for (const existingBox of survivedLabelBoxes) {\n            const minZoom = getIntersectionZoom(existingBox, labelBox, currentZoom);\n\n            if (minZoom > labelBox.minZoom && minZoom > existingBox.minZoom) {\n                labelBox.minZoom = minZoom;\n            }\n        }\n\n        labels[labelOffset + offsets.minZoom] = labelBox.minZoom;\n\n        survivedLabelBoxes.push(labelBox);\n    }\n}\n\n/**\n * Проверяет, пересекает ли область что-либо в плоскости\n *\n * @param arr Плоскость\n * @param width Ширина плоскости\n * @param bbox Проверяемая область\n */\nfunction collide(arr: Uint8Array, width: number, bbox: BBox): boolean {\n    const x1 = bbox.minX;\n    const y1 = bbox.minY;\n    const x2 = bbox.maxX;\n    const y2 = bbox.maxY;\n\n    for (let j = y1; j < y2; j++) {\n        const start = j * width + x1 >> 3;\n        const end = j * width + x2 >> 3;\n        let sum = 0;\n\n        // Если начальный байт равен конечному, то нужно проверить только его\n        if (start === end) {\n            sum = arr[start] & (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        } else {\n            // Проверяем начальный байт\n            sum = arr[start] & (255 >> (x1 & 7));\n            // Перебираем все промежуточные между начальным и конечным\n            for (let i = start + 1; i < end; i++) {\n                sum = arr[i] | sum;\n            }\n            // Проверяем конечный байт\n            sum = arr[end] & (255 << (8 - (x2 & 7))) | sum;\n        }\n\n        if (sum !== 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Закрашиваем переданную область на плоскости\n *\n * @param arr Плоскость\n * @param width Ширина плоскости\n * @param bbox Закрашиваемая область\n */\nfunction putToArray(arr: Uint8Array, width: number, bbox: BBox) {\n    const x1 = bbox.minX;\n    const y1 = bbox.minY;\n    const x2 = bbox.maxX;\n    const y2 = bbox.maxY;\n\n    for (let j = y1; j < y2; j++) {\n        const start = j * width + x1 >> 3;\n        const end = j * width + x2 >> 3;\n\n        // Если начальный байт равен конечному, то нужно закрасить биты только в нем\n        if (start === end) {\n            arr[start] = arr[start] | (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        } else {\n            // Закрашиваем биты в начальном байте\n            arr[start] = arr[start] | (255 >> (x1 & 7));\n            // Закрашиваем все промежуточные байты между начальным и конечным\n            for (let i = start + 1; i < end; i++) {\n                arr[i] = 255;\n            }\n            // Закрашиваем биты в коненом байте\n            arr[end] = arr[end] | (255 << (8 - (x2 & 7)));\n        }\n    }\n}\n\nfunction bboxIsEmpty(a: BBox): boolean {\n    return a.minX === a.maxX || a.minY === a.maxY;\n}\n\nfunction createBBox(\n    dst: BBox,\n    planeWidth: number,\n    planeHeight: number,\n    size: Vec2,\n    anchor: Vec2,\n    positionX: number,\n    positionY: number,\n    offset: number,\n): void {\n    const x1 = positionX - size[0] * anchor[0] - offset | 0;\n    const y1 = positionY - size[1] * anchor[1] - offset | 0;\n\n    const x2 = positionX + size[0] * (1 - anchor[0]) + offset | 0;\n    const y2 = positionY + size[1] * (1 - anchor[1]) + offset | 0;\n\n    // Обрезаем область по установленным границам плоскости\n    dst.minX = x1 > 0 ? (x1 < planeWidth ? x1 : planeWidth) : 0;\n    dst.minY = y1 > 0 ? (y1 < planeHeight ? y1 : planeHeight) : 0;\n    dst.maxX = x2 > 0 ? (x2 < planeWidth ? x2 : planeWidth) : 0;\n    dst.maxY = y2 > 0 ? (y2 < planeHeight ? y2 : planeHeight) : 0;\n}\n\nexport const testHandlers = {\n    collide,\n    putToArray,\n    bboxIsEmpty,\n    createBBox,\n    generalize,\n};\n","import { WorkerMessage } from '../types';\nimport { generalize } from './generalize';\n\nexport interface WorkerGlobalScope {\n    onmessage: (event: { data: WorkerMessage }) => void;\n    postMessage: (message: any, transfer?: any[]) => void;\n}\n\n// tslint:disable-next-line:no-default-export\nexport default (self: WorkerGlobalScope) => {\n    self.onmessage = (event) => {\n        generalize(event.data);\n\n        const { markers, labels } = event.data;\n\n        self.postMessage({\n            markerArray: markers,\n            labelArray: labels,\n        }, [\n            markers.buffer,\n            labels.buffer,\n        ]);\n    };\n};\n","import * as markerArray from './markerArray';\nimport * as labelArray from './labelArray';\nimport {\n    BBox,\n    PriorityGroup,\n    Sprite,\n    Marker,\n    WorkerMessage,\n    Job,\n    JobMessage,\n} from './types';\nimport work from 'webworkify-webpack';\n\nexport class General {\n    private worker: Worker;\n    private queue: Job[];\n    private currentJob: Job | undefined;\n    private markerArray: Float32Array;\n    private labelArray: Float32Array;\n\n    constructor() {\n        this.worker = work(require.resolve('./worker'));\n        this.queue = [];\n        this.currentJob = undefined;\n        this.markerArray = new Float32Array(1000 * markerArray.stride);\n        this.labelArray = new Float32Array(1000 * labelArray.stride);\n\n        this.worker.onmessage = (event) => {\n            if (this.currentJob === undefined) {\n                return;\n            }\n\n            const { markers, resolve } = this.currentJob;\n            const { data } = event;\n\n            markerArray.unpack(markers, data.markerArray);\n            labelArray.unpack(markers, data.labelArray);\n\n            this.markerArray = data.markerArray;\n            this.labelArray = data.labelArray;\n\n            this.currentJob = undefined;\n\n            this.dequeue();\n            resolve();\n        };\n    }\n\n    public generalize(\n        bounds: BBox,\n        priorityGroups: PriorityGroup[],\n        sprites: Sprite[],\n        markers: Marker[],\n        currentZoom: number,\n    ): Promise<void> {\n        const message: JobMessage = {\n            bounds,\n            priorityGroups,\n            sprites,\n            currentZoom,\n        };\n\n        const markerCount = markers.length;\n        const labelCount = markers.filter((marker) => marker.htmlLabel !== undefined).length;\n\n        return new Promise((resolve) => {\n            this.queue.push({ message, markers, resolve, markerCount, labelCount });\n            this.dequeue();\n        });\n    }\n\n    public clear() {\n        this.queue = [];\n    }\n\n    private pack(markers: Marker[], markerCount: number, labelCount: number): void {\n        if (markerCount * markerArray.stride > this.markerArray.length) {\n            this.markerArray = new Float32Array(markerCount * markerArray.stride);\n        }\n\n        if (labelCount * labelArray.stride > this.labelArray.length) {\n            this.labelArray = new Float32Array(labelCount * labelArray.stride);\n        }\n\n        markerArray.pack(this.markerArray, markers);\n        labelArray.pack(this.labelArray, markers, window.devicePixelRatio);\n    }\n\n    private dequeue() {\n        if (this.currentJob !== undefined) {\n            return;\n        }\n\n        const job = this.queue.shift();\n\n        if (job === undefined) {\n            return;\n        }\n\n        this.pack(job.markers, job.markerCount, job.labelCount);\n\n        const message = job.message as WorkerMessage;\n        message.markers = this.markerArray;\n        message.markerCount = job.markerCount;\n        message.labels = this.labelArray;\n        message.labelCount = job.labelCount;\n\n        this.worker.postMessage(message, [message.markers.buffer, message.labels.buffer]);\n\n        this.currentJob = job;\n    }\n}\n","export {\n    General,\n} from './General';\n\nexport {\n    Marker,\n    Sprite,\n    PriorityGroup,\n    BBox,\n} from './types';\n"],"sourceRoot":""}