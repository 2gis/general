{"version":3,"sources":["webpack:///dde090990a6feb572c38.worker.js","webpack:///webpack/bootstrap dde090990a6feb572c38","webpack:///./src/worker/generalize.ts","webpack:///./src/worker/index.ts","webpack:///./src/markerArray.ts"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","generalize","data","bounds","pixelRatio","priorityGroups","sprites","markers","markerCount","width","maxX","minX","height","maxY","minY","planeLength","plane","Uint8Array","currentDegradationPlane","degradationPlane","prevGroupIndex","__WEBPACK_IMPORTED_MODULE_0__markerArray__","pixelPositionX","pixelPositionY","isNaN","_a","iconIndex","margin","degradation","sprite","size","anchor","pixelDensity","createBBox","marginBBox","bboxIsEmpty","putToArray","degradationBBox","length","group","safeZone","set","j","markerOffset","groupIndex","collide","collideBBox","arr","bbox","x1","y1","x2","y2","start","end","sum","a","dst","positionX","positionY","offset","spriteScale","__WEBPACK_IMPORTED_MODULE_0__generalize__","onmessage","event","postMessage","offsets","stride","keys"],"mappings":"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","file":"dde090990a6feb572c38.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__markerArray__ = __webpack_require__(2);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = generalize;\n/* unused harmony export testHandlers */\n\nvar collideBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nvar marginBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nvar degradationBBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nfunction generalize(data) {\n    var bounds = data.bounds, pixelRatio = data.pixelRatio, priorityGroups = data.priorityGroups, sprites = data.sprites, markers = data.markers, markerCount = data.markerCount;\n    var width = (bounds.maxX - bounds.minX >> 3) + 1 << 3; // Ширина должна быть кратна 8\n    var height = bounds.maxY - bounds.minY;\n    var planeLength = width * height + 8 >> 3;\n    /**\n     * Алгоритм действует по принципу закрашивания плоскости маркерами.\n     * Плоскость – массив, каждый элемент которого представляет собой пиксель на экране.\n     * Для ускорения процесса используется битовой массив, 1 бит – 1 пиксель.\n     * Всего у нас есть три плоскости:\n     */\n    // Это первая, с помощью нее мы просто проверяем попадание маркеров с safeZone и вставляем их с margin\n    var plane = new Uint8Array(planeLength);\n    /**\n     * Следующие две используются для проверки на деградацию маркеров.\n     * Область деградации маркера текущей группы действует только на маркера из следующей группы\n     * и не влияет на другие маркера текущей группы.\n     * Поэтому их две:\n     */\n    // Одна – для проверки текущей группы с предыдущими\n    var currentDegradationPlane = new Uint8Array(planeLength);\n    // Вторая – для передачи в следующие группы\n    var degradationPlane = new Uint8Array(planeLength);\n    /**\n     * Одни и те же маркера могут участвовать в генерализации несколько раз,\n     * такие маркера имеют поле prevGroupIndex.\n     *\n     * Чтобы не делать лишнюю работу, и чтобы результат генерализации был устойчив,\n     * мы используем результаты предыдущей генерализации.\n     */\n    // Поэтому вначале закрашиваем плоскость повторно генерализуемыми маркерами\n    for (var i = 0; i < markerCount; i++) {\n        var prevGroupIndex = markers[i * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */] + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].prevGroupIndex];\n        var pixelPositionX = markers[i * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */] + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionX];\n        var pixelPositionY = markers[i * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */] + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionY];\n        // prevGroupIndex не равен NaN, если маркер уже проходил генерализацию\n        if (!isNaN(prevGroupIndex)) {\n            var _a = priorityGroups[prevGroupIndex], iconIndex = _a.iconIndex, margin = _a.margin, degradation = _a.degradation;\n            var sprite = sprites[iconIndex];\n            if (!sprite) {\n                // smth shit\n                continue;\n            }\n            var size = sprite.size, anchor = sprite.anchor, pixelDensity = sprite.pixelDensity;\n            // Вставляем их на основную плоскость и плоскость деградции без всяких проверок\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, margin);\n            if (!bboxIsEmpty(marginBBox)) {\n                putToArray(plane, width, marginBBox);\n            }\n            createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, degradation);\n            if (!bboxIsEmpty(degradationBBox)) {\n                putToArray(degradationPlane, width, degradationBBox);\n            }\n        }\n    }\n    // Здесь начинает работу основной алгоритм генерализации.\n    // У нас два вложенных цикла: по группам -> по маркерам.\n    for (var i = 0; i < priorityGroups.length; i++) {\n        var group = priorityGroups[i];\n        var safeZone = group.safeZone, iconIndex = group.iconIndex, margin = group.margin, degradation = group.degradation;\n        var sprite = sprites[iconIndex];\n        if (!sprite) {\n            // smth shit\n            continue;\n        }\n        var size = sprite.size, anchor = sprite.anchor, pixelDensity = sprite.pixelDensity;\n        // Копируем область деградации от предудщих групп,\n        // чтобы маркера текущей группы не влияли друг на друга.\n        currentDegradationPlane.set(degradationPlane);\n        for (var j = 0; j < markerCount; j++) {\n            var markerOffset = j * __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"a\" /* stride */];\n            var groupIndex = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].groupIndex];\n            var prevGroupIndex = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].prevGroupIndex];\n            var pixelPositionX = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionX];\n            var pixelPositionY = markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].pixelPositionY];\n            // Пропускаем маркера, чей изначальный groupIndex больше индекса текущей перебираемой группы.\n            // Такие маркера будут проверены в следующах группах.\n            // Также пропускаем повторно генерализуемые маркера.\n            if (groupIndex > i || !isNaN(prevGroupIndex)) {\n                continue;\n            }\n            // Маркер первый раз попал в область деградации – пропускаем\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, margin);\n            if (bboxIsEmpty(marginBBox) ||\n                (groupIndex === i && collide(currentDegradationPlane, width, marginBBox))) {\n                continue;\n            }\n            // Область маркера пересекает область уже вставшего маркера – пропускаем\n            createBBox(collideBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, safeZone);\n            if (bboxIsEmpty(collideBBox)) {\n                continue;\n            }\n            if (!collide(plane, width, collideBBox)) {\n                createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity, pixelPositionX, pixelPositionY, degradation);\n                // Если все хорошо и маркер выжил, закрашиваем его в двух плоскостях\n                putToArray(plane, width, marginBBox);\n                putToArray(degradationPlane, width, degradationBBox);\n                markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].iconIndex] = iconIndex;\n                markers[markerOffset + __WEBPACK_IMPORTED_MODULE_0__markerArray__[\"b\" /* offsets */].prevGroupIndex] = i;\n            }\n        }\n    }\n}\n;\n/**\n * Проверяет, пересекает ли область что-либо в плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Проверяемая область\n * @returns {boolean}\n */\nfunction collide(arr, width, bbox) {\n    var x1 = bbox.minX;\n    var y1 = bbox.minY;\n    var x2 = bbox.maxX;\n    var y2 = bbox.maxY;\n    for (var j = y1; j < y2; j++) {\n        var start = j * width + x1 >> 3;\n        var end = j * width + x2 >> 3;\n        var sum = 0;\n        // Если начальный байт равен конечному, то нужно проверить только его\n        if (start === end) {\n            sum = arr[start] & (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        }\n        else {\n            // Проверяем начальный байт\n            sum = arr[start] & (255 >> (x1 & 7));\n            // Перебираем все промежуточные между начальным и конечным\n            for (var i = start + 1; i < end; i++) {\n                sum = arr[i] | sum;\n            }\n            // Проверяем конечный байт\n            sum = arr[end] & (255 << (8 - (x2 & 7))) | sum;\n        }\n        if (sum !== 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Закрашиваем переданную область на плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Закрашиваемая область\n */\nfunction putToArray(arr, width, bbox) {\n    var x1 = bbox.minX;\n    var y1 = bbox.minY;\n    var x2 = bbox.maxX;\n    var y2 = bbox.maxY;\n    for (var j = y1; j < y2; j++) {\n        var start = j * width + x1 >> 3;\n        var end = j * width + x2 >> 3;\n        // Если начальный байт равен конечному, то нужно закрасить биты только в нем\n        if (start === end) {\n            arr[start] = arr[start] | (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        }\n        else {\n            // Закрашиваем биты в начальном байте\n            arr[start] = arr[start] | (255 >> (x1 & 7));\n            // Закрашиваем все промежуточные байты между начальным и конечным\n            for (var i = start + 1; i < end; i++) {\n                arr[i] = 255;\n            }\n            // Закрашиваем биты в коненом байте\n            arr[end] = arr[end] | (255 << (8 - (x2 & 7)));\n        }\n    }\n}\nfunction isNaN(a) {\n    return a !== a;\n}\nfunction bboxIsEmpty(a) {\n    return a.minX === a.maxX || a.minY === a.maxY;\n}\nfunction createBBox(dst, width, height, pixelRatio, size, anchor, pixelDensity, positionX, positionY, offset) {\n    var spriteScale = pixelRatio / pixelDensity;\n    var x1 = positionX * pixelRatio - size[0] * spriteScale * anchor[0] - offset | 0;\n    var y1 = positionY * pixelRatio - size[1] * spriteScale * anchor[1] - offset | 0;\n    var x2 = positionX * pixelRatio + size[0] * spriteScale * (1 - anchor[0]) + offset | 0;\n    var y2 = positionY * pixelRatio + size[1] * spriteScale * (1 - anchor[1]) + offset | 0;\n    // Обрезаем область по установленным границам плоскости\n    dst.minX = x1 > 0 ? (x1 < width ? x1 : width) : 0;\n    dst.minY = y1 > 0 ? (y1 < height ? y1 : height) : 0;\n    dst.maxX = x2 > 0 ? (x2 < width ? x2 : width) : 0;\n    dst.maxY = y2 > 0 ? (y2 < height ? y2 : height) : 0;\n}\nvar testHandlers = {\n    collide: collide,\n    putToArray: putToArray,\n    isNaN: isNaN,\n    bboxIsEmpty: bboxIsEmpty,\n    createBBox: createBBox,\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__generalize__ = __webpack_require__(0);\n\nonmessage = function (event) {\n    var data = event.data;\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__generalize__[\"a\" /* generalize */])(data);\n    postMessage(data.markers);\n};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return offsets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return stride; });\n// Оффсеты должны быть пронумерованы по порядку\n// Оффсеты должны быть пронумерованы по порядку\nvar offsets = {\n    pixelPositionX: 0,\n    pixelPositionY: 1,\n    groupIndex: 2,\n    iconIndex: 3,\n    prevGroupIndex: 4,\n};\nvar stride = Object.keys(offsets).length;\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// dde090990a6feb572c38.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap dde090990a6feb572c38","import { BBox, Vec2, WorkerMessage } from '../types';\nimport { stride, offsets } from '../markerArray';\n\nconst collideBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nconst marginBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\nconst degradationBBox: BBox = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\nexport function generalize(data: WorkerMessage) {\n    const { bounds, pixelRatio, priorityGroups, sprites, markers, markerCount } = data;\n\n    const width = (bounds.maxX - bounds.minX >> 3) + 1 << 3; // Ширина должна быть кратна 8\n    const height = bounds.maxY - bounds.minY;\n\n    const planeLength = width * height + 8 >> 3;\n\n    /**\n     * Алгоритм действует по принципу закрашивания плоскости маркерами.\n     * Плоскость – массив, каждый элемент которого представляет собой пиксель на экране.\n     * Для ускорения процесса используется битовой массив, 1 бит – 1 пиксель.\n     * Всего у нас есть три плоскости:\n     */\n\n    // Это первая, с помощью нее мы просто проверяем попадание маркеров с safeZone и вставляем их с margin\n    const plane = new Uint8Array(planeLength);\n\n    /**\n     * Следующие две используются для проверки на деградацию маркеров.\n     * Область деградации маркера текущей группы действует только на маркера из следующей группы\n     * и не влияет на другие маркера текущей группы.\n     * Поэтому их две:\n     */\n\n    // Одна – для проверки текущей группы с предыдущими\n    const currentDegradationPlane = new Uint8Array(planeLength);\n    // Вторая – для передачи в следующие группы\n    const degradationPlane = new Uint8Array(planeLength);\n\n    /**\n     * Одни и те же маркера могут участвовать в генерализации несколько раз,\n     * такие маркера имеют поле prevGroupIndex.\n     *\n     * Чтобы не делать лишнюю работу, и чтобы результат генерализации был устойчив,\n     * мы используем результаты предыдущей генерализации.\n     */\n\n    // Поэтому вначале закрашиваем плоскость повторно генерализуемыми маркерами\n    for (let i = 0; i < markerCount; i++) {\n        const prevGroupIndex = markers[i * stride + offsets.prevGroupIndex];\n        const pixelPositionX = markers[i * stride + offsets.pixelPositionX];\n        const pixelPositionY = markers[i * stride + offsets.pixelPositionY];\n\n        // prevGroupIndex не равен NaN, если маркер уже проходил генерализацию\n        if (!isNaN(prevGroupIndex)) {\n            const { iconIndex, margin, degradation } = priorityGroups[prevGroupIndex];\n            const sprite = sprites[iconIndex];\n\n            if (!sprite) {\n                // smth shit\n                continue;\n            }\n\n            const { size, anchor, pixelDensity } = sprite;\n\n            // Вставляем их на основную плоскость и плоскость деградции без всяких проверок\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity,\n                pixelPositionX, pixelPositionY, margin);\n\n            if (!bboxIsEmpty(marginBBox)) {\n                putToArray(plane, width, marginBBox);\n            }\n\n            createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity,\n                pixelPositionX, pixelPositionY, degradation);\n\n            if (!bboxIsEmpty(degradationBBox)) {\n                putToArray(degradationPlane, width, degradationBBox);\n            }\n        }\n    }\n\n    // Здесь начинает работу основной алгоритм генерализации.\n    // У нас два вложенных цикла: по группам -> по маркерам.\n    for (let i = 0; i < priorityGroups.length; i++) {\n        const group = priorityGroups[i];\n        const { safeZone, iconIndex, margin, degradation } = group;\n        const sprite = sprites[iconIndex];\n\n        if (!sprite) {\n            // smth shit\n            continue;\n        }\n\n        const { size, anchor, pixelDensity } = sprite;\n\n        // Копируем область деградации от предудщих групп,\n        // чтобы маркера текущей группы не влияли друг на друга.\n        currentDegradationPlane.set(degradationPlane);\n\n        for (let j = 0; j < markerCount; j++) {\n            const markerOffset = j * stride;\n\n            const groupIndex = markers[markerOffset + offsets.groupIndex];\n            const prevGroupIndex = markers[markerOffset + offsets.prevGroupIndex];\n            const pixelPositionX = markers[markerOffset + offsets.pixelPositionX];\n            const pixelPositionY = markers[markerOffset + offsets.pixelPositionY];\n\n            // Пропускаем маркера, чей изначальный groupIndex больше индекса текущей перебираемой группы.\n            // Такие маркера будут проверены в следующах группах.\n            // Также пропускаем повторно генерализуемые маркера.\n            if (groupIndex > i || !isNaN(prevGroupIndex)) {\n                continue;\n            }\n\n            // Маркер первый раз попал в область деградации – пропускаем\n            createBBox(marginBBox, width, height, pixelRatio, size, anchor, pixelDensity,\n                pixelPositionX, pixelPositionY, margin);\n            if (bboxIsEmpty(marginBBox) ||\n                (groupIndex === i && collide(currentDegradationPlane, width, marginBBox))\n            ) {\n                continue;\n            }\n\n            // Область маркера пересекает область уже вставшего маркера – пропускаем\n            createBBox(collideBBox, width, height, pixelRatio, size, anchor, pixelDensity,\n                pixelPositionX, pixelPositionY, safeZone);\n            if (bboxIsEmpty(collideBBox)) {\n                continue;\n            }\n\n            if (!collide(plane, width, collideBBox)) {\n                createBBox(degradationBBox, width, height, pixelRatio, size, anchor, pixelDensity,\n                    pixelPositionX, pixelPositionY, degradation);\n\n                // Если все хорошо и маркер выжил, закрашиваем его в двух плоскостях\n                putToArray(plane, width, marginBBox);\n                putToArray(degradationPlane, width, degradationBBox);\n\n                markers[markerOffset + offsets.iconIndex] = iconIndex;\n                markers[markerOffset + offsets.prevGroupIndex] = i;\n            }\n        }\n    }\n};\n\n/**\n * Проверяет, пересекает ли область что-либо в плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Проверяемая область\n * @returns {boolean}\n */\nfunction collide(arr: Uint8Array, width: number, bbox: BBox): boolean {\n    const x1 = bbox.minX;\n    const y1 = bbox.minY;\n    const x2 = bbox.maxX;\n    const y2 = bbox.maxY;\n\n    for (let j = y1; j < y2; j++) {\n        const start = j * width + x1 >> 3;\n        const end = j * width + x2 >> 3;\n        let sum = 0;\n\n        // Если начальный байт равен конечному, то нужно проверить только его\n        if (start === end) {\n            sum = arr[start] & (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        } else {\n            // Проверяем начальный байт\n            sum = arr[start] & (255 >> (x1 & 7));\n            // Перебираем все промежуточные между начальным и конечным\n            for (let i = start + 1; i < end; i++) {\n                sum = arr[i] | sum;\n            }\n            // Проверяем конечный байт\n            sum = arr[end] & (255 << (8 - (x2 & 7))) | sum;\n        }\n\n        if (sum !== 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Закрашиваем переданную область на плоскости\n *\n * @param {Uint8Array} arr Плоскость\n * @param {number} width Ширина плоскости\n * @param {BBox} bbox Закрашиваемая область\n */\nfunction putToArray(arr: Uint8Array, width: number, bbox: BBox) {\n    const x1 = bbox.minX;\n    const y1 = bbox.minY;\n    const x2 = bbox.maxX;\n    const y2 = bbox.maxY;\n\n    for (let j = y1; j < y2; j++) {\n        const start = j * width + x1 >> 3;\n        const end = j * width + x2 >> 3;\n\n        // Если начальный байт равен конечному, то нужно закрасить биты только в нем\n        if (start === end) {\n            arr[start] = arr[start] | (255 >> (x1 & 7) & 255 << (8 - (x2 & 7)));\n        } else {\n            // Закрашиваем биты в начальном байте\n            arr[start] = arr[start] | (255 >> (x1 & 7));\n            // Закрашиваем все промежуточные байты между начальным и конечным\n            for (let i = start + 1; i < end; i++) {\n                arr[i] = 255;\n            }\n            // Закрашиваем биты в коненом байте\n            arr[end] = arr[end] | (255 << (8 - (x2 & 7)));\n        }\n    }\n}\n\nfunction isNaN(a) {\n    return a !== a;\n}\n\nfunction bboxIsEmpty(a: BBox): boolean {\n    return a.minX === a.maxX || a.minY === a.maxY;\n}\n\nfunction createBBox(\n    dst: BBox,\n    width: number,\n    height: number,\n    pixelRatio: number,\n    size: Vec2,\n    anchor: Vec2,\n    pixelDensity: number,\n    positionX: number,\n    positionY: number,\n    offset: number,\n): void {\n    const spriteScale = pixelRatio / pixelDensity;\n\n    const x1 = positionX * pixelRatio - size[0] * spriteScale * anchor[0] - offset | 0;\n    const y1 = positionY * pixelRatio - size[1] * spriteScale * anchor[1] - offset | 0;\n\n    const x2 = positionX * pixelRatio + size[0] * spriteScale * (1 - anchor[0]) + offset | 0;\n    const y2 = positionY * pixelRatio + size[1] * spriteScale * (1 - anchor[1]) + offset | 0;\n\n    // Обрезаем область по установленным границам плоскости\n    dst.minX = x1 > 0 ? (x1 < width ? x1 : width) : 0;\n    dst.minY = y1 > 0 ? (y1 < height ? y1 : height) : 0;\n    dst.maxX = x2 > 0 ? (x2 < width ? x2 : width) : 0;\n    dst.maxY = y2 > 0 ? (y2 < height ? y2 : height) : 0;\n}\n\nexport const testHandlers = {\n    collide,\n    putToArray,\n    isNaN,\n    bboxIsEmpty,\n    createBBox,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/worker/generalize.ts","import { generalize } from './generalize';\nonmessage = function (event) {\n    var data = event.data;\n    generalize(data);\n    postMessage(data.markers);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/ts-loader!./src/worker/index.ts","// Оффсеты должны быть пронумерованы по порядку\nexport const offsets = {\n    pixelPositionX: 0,\n    pixelPositionY: 1,\n    groupIndex: 2,\n    iconIndex: 3,\n    prevGroupIndex: 4,\n};\n\nexport const stride = Object.keys(offsets).length;\n\n\n\n// WEBPACK FOOTER //\n// ./src/markerArray.ts"],"sourceRoot":""}